# -*- coding: utf-8 -*-
"""
/***************************************************************************
 processBaseLineDialog
                                 A QGIS plugin
 Plugin que funciona como complemento al plugin Colector. Su función es procesar las líneas base de la información recolectada haciendo uso de RTKLIB tanto para convertir los archivos binarios creados a partir de la colección, como para realizar la corrección diferencial.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-04-18
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Alexander Pretel Díaz
        email                : alexander.pretel@correounivalle.edu.co
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import ast
import subprocess
from PyQt5.QtCore import QThread, pyqtSignal
import time
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
import platform
from qgis.utils import *
from qgis.core import *
from qgis.gui import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'process_dialog_base.ui'))


class processBaseLineDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(processBaseLineDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.direccionProyecto = None
        self.dirObsBase = None
        self.dirNavBase = None
        self.show()
        self.iface = iface
        self.DirProyect.clicked.connect(self.proyecto)
        self.ObsFile.clicked.connect(self.fileObsBaseFunc)
        self.NavFile.clicked.connect(self.fileNavBaseFunc)
        self.proc = process()
        self.proc._signal.connect(self.updateProgressBar)
        self.proc._str.connect(self.setFormatProgressBar)
        self.procesar.clicked.connect(self.processBaseLineInFolder)


    def proyecto(self):
        if platform.system() == 'Windows':
            self.direccionProyecto = QtWidgets.QFileDialog.getExistingDirectory(self, 'Abrir proyecto',
                                                                                os.path.dirname(__file__)).replace("/",
                                                                                                               "\\")
        elif platform.system() == "Linux":
            self.direccionProyecto = QtWidgets.QFileDialog.getExistingDirectory(self, 'Abrir proyecto', r"~/")
        self.lineEdit_4.setText(str(self.direccionProyecto))
        print(self.direccionProyecto)

    def fileObsBaseFunc(self):
        if platform.system() == 'Windows':
            self.dirObsBase = str(QtWidgets.QFileDialog.getOpenFileName(self, 'Abrir archivo obs de la base', '',
                                                                    "RINEX OBS(*.obs *.*O *.*o)")[0].replace("/", "\\"))
        elif platform.system() == "Linux":
            self.dirObsBase = str(QtWidgets.QFileDialog.getOpenFileName(self, 'Abrir archivo obs de la base', '',
                                                                    "RINEX OBS(*.obs *.*O *.*o)")[0])
        self.lineEdit_5.setText(str(self.dirObsBase))

    def fileNavBaseFunc(self):
        if platform.system() == 'Windows':
            self.dirNavBase = str(QtWidgets.QFileDialog.getOpenFileName(self, 'Abrir archivo nav de la base', '',
                                                                    "RINEX OBS(*.nav *.*N *.*n)")[0].replace("/", "\\"))
        elif platform.system() == "Linux":
            self.dirNavBase = str(QtWidgets.QFileDialog.getOpenFileName(self, 'Abrir archivo nav de la base', '',
                                                                    "RINEX OBS(*.nav *.*N *.*n)")[0])
        self.lineEdit_3.setText(str(self.dirNavBase))

    def processBaseLineInFolder(self):
        print(self.direccionProyecto, self.dirObsBase, self.dirNavBase)
        self.proc.run1(self.direccionProyecto, self.dirObsBase, self.dirNavBase)

    def updateProgressBar(self, msg):
        if float(msg) > -1:
            self.progressBar.setValue(int(msg))
        if self.progressBar.value() == 99:
            self.progressBar.setValue(0)
        if float(msg) == -1:
            self.direccionProyecto = None
            self.lineEdit_4.setText('')
            self.progressBar.setValue(0)
            self.destroy()

    def setFormatProgressBar(self, msg):
        print(msg)
        print(isinstance(msg, str))

        if isinstance(msg, str):
            print(msg)
            # self.progressBar.setFormat(str(msg))
            # self.progressBar.setAlignment(Qt.AlignCenter)

class process(QThread):
    _signal = pyqtSignal(int)
    _str = pyqtSignal(str)

    def __init__(self):
        super(process, self).__init__()
        self.directionFolder = None
        self.directionObsBase = None
        self.directionNavBase = None
        self.iface = iface

    def __del__(self):
        self.wait()

    def run1(self, dire: str, obsBase: str, navBase: str):
        try:
            print("run1: ", dire)
            lstDir = os.walk(dire)
            subcarpeta = [sub[0] for sub in lstDir]
            print(subcarpeta)
            for archivo in range(0, len(subcarpeta)):
                dire = subcarpeta[archivo]
                print(dire)
                direccionCarpeta = os.walk(dire)
                nombreCapa = dire.split(os.sep)[-1]
                txt = open(dire + os.sep + nombreCapa + ".txt")
                lineas = txt.readlines()
                numeroArchivos = len(lineas) - 1
                txt.close()
                shp = dire + os.sep + nombreCapa +".shp"
                shapeExport = os.path.join(os.path.abspath(dire + r"..{0}..{0}..{0}..{0}Export".format(os.sep)) + os.sep + nombreCapa+".shp")
                sf = QgsVectorLayer(shapeExport)
                field = sf.fields()
                typeGeom = sf.geometryType()
                crs = sf.crs()
                del(sf)
                print("shapeExpor: ", shapeExport)
                print("geom: ", typeGeom)
                print("shp: ", shp)
                if typeGeom == QgsWkbTypes.PointGeometry:
                    w = QgsVectorFileWriter(vectorFileName=str(shp), fileEncoding='UTF-8', fields=field, geometryType=QgsWkbTypes.Point, srs=crs, driverName='ESRI Shapefile')
                elif typeGeom == QgsWkbTypes.LineGeometry:
                    w = QgsVectorFileWriter(vectorFileName=str(shp), fileEncoding='UTF-8', fields=field, geometryType=QgsWkbTypes.LineString, srs=crs, driverName='ESRI Shapefile')
                elif typeGeom == QgsWkbTypes.PolygonGeometry:
                    w = QgsVectorFileWriter(vectorFileName=str(shp), fileEncoding='UTF-8', fields=field, geometryType=QgsWkbTypes.Polygon, srs=crs, driverName='ESRI Shapefile')
                procesados = 0
                dict = {}
                for root, dirs, files in direccionCarpeta:
                    numArchivos = len(files)
                    for fichero in files:
                        (nombreFichero, extension) = os.path.splitext(fichero)
                        if (extension == ".ubx"):
                            if typeGeom == QgsWkbTypes.PointGeometry:
                                obsRover = "{0}{2}{1}.obs".format(root, fichero.split(".")[0], os.sep)
                                self.convbin(obsRover, root, fichero)
                                i = 0
                                a = True
                                while a:
                                    if i == 5 or i == 8 or i > 10:
                                        self.convbin(obsRover, root, fichero)
                                        time.sleep(3)
                                    elif i > 15:
                                        a = False
                                        break
                                    status = self.rnx2rtkp(obsRover, obsBase, navBase)

                                    out, err = status.communicate(timeout=10)
                                    try:
                                        #print(out)
                                        #print("result -----------------------------------")
                                        if platform.system() == 'Windows':
                                            result = out.decode('utf-8').splitlines()[3].split(",")
                                            #print(result)
                                        elif platform.system() == 'Linux':
                                            result = out.decode('utf-8').splitlines()[2].split(",")
                                            #print(result)
                                        a = False
                                        break
                                    except:
                                        i += 1
                                        pass

                                lat = result[1]
                                long = result[2]
                                alt = result[3]
                                solution = result[4]
                                self._str.emit(str("lat: {0}  long: {1}".format(str(float(lat)), str(float(long)))))
                                for dict in lineas:
                                    res = ast.literal_eval(dict)
                                    if res["id"][0] == int(fichero.split(".")[0]):
                                        feat = QgsFeature()
                                        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(long), float(lat))))
                                        feat.setAttributes(list(res[str(key)][0] for key in res.keys()))
                                        w.addFeature(feat)
                                        procesados += 1
                                        # print((procesados/numeroArchivos)*100)
                                        self._signal.emit(float((procesados / numeroArchivos) * 100))
                                        # self.progressBar.setValue((procesados/numeroArchivos)*100)
                            elif typeGeom == QgsWkbTypes.LineGeometry or typeGeom == QgsWkbTypes.PolygonGeometry:
                                obsRover = "{0}{2}{1}.obs".format(root, fichero.split(".")[0], os.sep)
                                #print(obsRover)
                                self.convbin(obsRover, root, fichero)
                                i = 0
                                a = True
                                while a:
                                    if i == 5 or i == 8 or i > 10:
                                        self.convbin(obsRover, root, fichero)
                                        time.sleep(3)
                                    elif i > 15:
                                        a = False
                                        break
                                    status = status = self.rnx2rtkp(obsRover, obsBase, navBase)
                                    time.sleep(1)
                                    out, err = status.communicate(timeout=10)
                                    try:
                                        if platform.system() == 'Windows':
                                            result = out.decode('utf-8').splitlines()[3].split(",")
                                            #print(result)
                                        elif platform.system() == 'Linux':
                                            result = out.decode('utf-8').splitlines()[2].split(",")
                                        break
                                    except:
                                        i += 1
                                        pass
                                #print(out)
                                # result = out.decode('utf-8').splitlines()[3].split(",")
                                lat = result[1]
                                long = result[2]
                                alt = result[3]
                                solution = result[4]
                                if nombreFichero.split("_")[0] in dict:
                                    dict[nombreFichero.split("_")[0]].append([nombreFichero.split("_")[1], lat, long])
                                else:
                                    dict[nombreFichero.split("_")[0]] = [[nombreFichero.split("_")[1], lat, long]]
                                procesados += 1
                                self._signal.emit(float((procesados / (2 * numArchivos)) * 100))
                                # print(dict)
                if typeGeom == QgsWkbTypes.LineGeometry:
                    print("POLYLINE")
                    for a in dict:
                        #print(a)
                        ordenados = sorted(dict[a], key=lambda id: id[0])
                        for linea in lineas:
                            res = ast.literal_eval(linea)
                            if int(a) == int(res["id"][0]):
                                coordenadas = []
                                for longlat in ordenados:
                                    coordenadas.append(QgsPoint(float(longlat[2]), float(longlat[1])))
                                #print(coordenadas, "---------------------------")
                                feat = QgsFeature()
                                feat.setGeometry(QgsGeometry.fromPolyline(coordenadas))
                                feat.setAttributes(list(res[str(key)][0] for key in res.keys()))
                                w.addFeature(feat)
                                procesados += 1
                                #print((procesados / numeroArchivos) * 100)
                                self._signal.emit(float((procesados / (2 * numArchivos)) * 100))

                elif typeGeom == QgsWkbTypes.PolygonGeometry:
                    for a in dict:
                        #print(a)
                        ordenados = sorted(dict[a], key=lambda id: id[0])
                        for linea in lineas:
                            res = ast.literal_eval(linea)
                            if int(a) == int(res["id"][0]):
                                coordenadas = []
                                for longlat in ordenados:
                                    coordenadas.append([float(longlat[2]), float(longlat[1])])
                                #print(coordenadas, "---------------------------")
                                feat = QgsFeature()
                                feat.setGeometry(QgsGeometry.fromPolygon(coordenadas))
                                feat.setAttributes(list(res[str(key)][0] for key in res.keys()))
                                w.addFeature(feat)
                                procesados += 1
                                self._signal.emit(float((procesados / (2 * numArchivos)) * 100))
                iface.addVectorLayer(str(shp), '', 'ogr')
                del(w)
                self._signal.emit(float(-1))
        except ValueError as e:
            self.iface.messageBar().pushMessage(u'Colector Infomra', str(e),
                                                level=Qgis.Critical)

    def convbin(self, obsRover, root, fichero):
        if platform.system() == 'Linux':
            subprocess.Popen(
                ["convbin", "-v", "2.11",
                 "-hm", str(fichero.split(".")[0]), "-f", "1", "-o", str(obsRover),
                 "{0}{2}{1}".format(str(root), str(fichero), os.sep)],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
        elif platform.system() == 'Windows':
            subprocess.Popen(
                [os.path.join(os.path.dirname(__file__),
                              "bin{0}convbin.exe".format(os.sep)), "-v", "2.11",
                 "-hm", str(fichero.split(".")[0]), "-f", "1", "-o", str(obsRover),
                 "{0}{2}{1}".format(str(root), str(fichero), os.sep)],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)

    def rnx2rtkp(self, obsRover, obsBase, navBase):
        if platform.system() == 'Windows':
            status = subprocess.Popen(
                [os.path.join(os.path.dirname(__file__), "bin{0}rnx2rtkp.exe".format(os.sep)), "-k",
                 os.path.join(os.path.dirname(__file__), r"configRtkPost.conf"),
                 str(obsRover), str(obsBase), str(navBase)], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, shell=False)
            return(status)
        elif platform.system() == 'Linux':
            status = subprocess.Popen(
                [r"rnx2rtkp", "-k",
                 os.path.join(os.path.dirname(__file__), r"configRtkPost.conf"),
                 str(obsRover), str(obsBase), str(navBase)], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE, shell=False)
            return(status)
